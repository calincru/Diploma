\chapter{Design and implementation}\label{chapter:design}

In this chapter we delve into the design and the implementation details of
\emph{iptables-to-sefl}, the tool we built to generate SEFL models from
iptables configurations.

We start by presenting the template we use to build models for iptables-enabled
devices.  We increase its complexity and the amount of details as we gradually
introduce features supported in the finalized project.  Following that, we
cover most of the implementation-related decisions that are particularly
distinctive to our tool.  We sum up this chapter with an overview of the
limitations that come up along the way.


\section{Towards a model}

Building a SEFL model which can then be verified by SymNet is as simple as
providing two Map data structures, as discussed in
\labelindexref{Section}{sec:symnet-sefl}:
\begin{enumerate}[a)]
  \item the first one, from \emph{source} ports to \emph{destination} ports; it
    implicitly defines a directed graph which is our formal way of defining
    networks.
  \item the other one, from \emph{ports} (i.e. nodes in this graph) to SEFL
    instructions; this one captures the actual behaviour of each network
    element.
\end{enumerate}

The goal of this chapter is to show how we provide these Maps starting from a
deployment of iptables rules, in such a way that once fed into SymNet, the
verified behaviour is that of an iptables-enabled device.  To do so, in this
section we start by describing the high-level idea of our model as well as the
underlying algorithms that we use.

\bigskip

To ease the bootstrapping of our modelling process, we notice that packet
processing in netfilter is built around the routing decision.  To be more
precise, in \labelindexref{Figure}{fig:iptables-organization} from the previous
chapter there are three points in the processing stack where the routing table
is consulted.  Moreover, a routing decision was the only feature of the simple
router model we introduced in \labelindexref{Section}{sub-sec:building-models}.
Well-known software engineering practices tell us that we should reuse existing
functionality as long as it makes sense to do so.  In our scenario, it does.

Thus, in the first iteration towards our end goal of reaching an iptables model
from a router model we separate the only routing decision featured in
\labelindexref{Figure}{fig:router-model} into three different routing
decisions, as shown in \labelindexref{Figure}{fig:iptables-1}.

\begin{figure}[h]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[scale=0.5]{src/img/iptables-1}
  \caption[iptables model (I): Separated routing decisions.]{iptables model
  (I): Separated routing decisions.  Straight arrows correspond to directed
  edges in our network model, while dotted-arrows correspond to possible
  \emph{Forward} instructions directing traffic on those paths. Note that it is
  important to assign unique port names because there are no name scopes;
  implementation-wise, this is achieved by prefixing the \emph{role} of the
  port (e.g.  \emph{in}, \emph{out}) by the unique name of the \emph{virtual
  device} it belongs to.}
  \label{fig:iptables-1}
\end{figure}

Note that we \emph{specialized} each one of the three new routing decisions:
\begin{itemize}
  \item \textbf{ingress} routing decision: for traffic that \textbf{enters}
    this device
  \item \textbf{egress} routing decision: for traffic that \textbf{exits} this
    device
  \item \textbf{output} (sometimes \emph{local}) routing decision: for traffic
    that is \textbf{generated by} this device
\end{itemize}

Another thing that might not be obvious at first is that the behaviour of two
out of three of them has changed.  It is easier to see this if we focus on the
one for locally generated packets.  We notice that its single output port is
connected to the input port of the \emph{egress} one, which means that all
packets that enter it will follow that path.  Thus, it does not capture the
usual routing decision behaviour which simply forwards packets to output ports
based on some logic (i.e. destination IP and routing table).  The same applies
to \emph{ingress} which only partitions packets based on whether they should be
delivered locally or not.  It turns out that this new behaviour is essential to
iptables, to enable matching against the output interface in the
FORWARD/POSTROUTING chains, or to allow redirecting traffic in nat/OUTPUT. It
is usually implemented by storing the decision (output port) instead of
forwarding packets based on it.

As simple as this step might be, it still corresponds to a valid iptables
configuration: the \emph{void} one.  This is a valuable remark because it
allows us to validate future, more complex versions of the model by comparing
their output when all chains/tables are empty to that of this
\emph{featureless} one (a form of \textbf{regression testing}).

\bigskip

To advance one more step in our attempt to reach a model of an iptables-enabled
device, let us observe the similarity between
\labelindexref{Figure}{fig:iptables-1} and
\labelindexref{Figure}{fig:iptables-organization} from
\labelindexref{Chapter}{chapter:background}.  It seems that all we need to do
in order to make them be truly alike is to add some \emph{virtual devices} to
model chain traversal. The resulting schema is shown in
\labelindexref{Figure}{fig:iptables-2}.

\begin{figure}[h]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[scale=0.45]{src/img/iptables-2}
  \caption[iptables model (II): Incorporated chain virtual devices.]{iptables
  model (II): Incorporated chain virtual devices.  The purple squares are
  Iptables Virtual Devices (IVDs) and they abstract chain traversal logic.}
  \label{fig:iptables-2}
\end{figure}

The new virtual devices are called \textbf{Iptables Virtual Devices}
(IVD)\abbrev{IVD}{Iptables Virtual Devices} and have the distinctive feature
that always have one input port and two output ports: an output port
corresponding to \emph{accepting} packets, whether modified or not, and another
one for \emph{dropping} packets, which is especially useful when modelling the
filter table.  In \labelindexref{Figure}{fig:iptables-2}, the former
corresponds to the output ports (blue circles) of IVDs (purple squares) which
are linked to the next virtual device in the processing stack.  On the other
hand, the \emph{dropping} ports are not connected to any other ports and have a
SEFL \hltexttt{Fail} instruction associated with them.

So what does this new augmented model buy us?  Firstly, as already mentioned,
it is closer (at least from a high-level perspective for now) to the internal
organization of iptables.  Secondly, it further separates the actual iptables
logic to be modelled on a per-chain basis.  In fact, this can be further
divided by acknowledging that each chain IVD, as it represented here, is a
sequence of concrete (per table) chain traversals; for instance, there are 3
tables that might define rules in the PREROUTING chain: raw, mangle, nat.
Therefore, we can improve our model by splitting each chain IVD as shown in
\labelindexref{Figure}{fig:iptables-2-composition}.

\begin{figure}[h]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[scale=0.5]{src/img/iptables-2-composition}
  \caption[Concrete (per-table) chains make up individual chain IVDs.]{Concrete
  (per-table) chains make up individual chain IVDs.}
  \label{fig:iptables-2-composition}
\end{figure}

Thus, we claim that we reduced the problem of modelling an iptables-enabled
device to that of implementing (in SEFL) the traversal of a chain of rules.
\labelindexref{Algorithm}{algo:chain-traversal} captures the naive but
straightforward way of doing this:

\begin{algorithm}[H]
  \SetKwInOut{Inputs}{inputs}
  \SetKwInOut{Output}{output}
  \SetKwProg{TraverseChain}{TraverseChain}{}{}

  \TraverseChain{$(C, P)$}{
    \Inputs{A chain $C$ and a packet $P$}
    \Output{The target $T$ to jump to}

    \ForEach{rule $r \in$ C.rules}{
      \If{$m(p)$ is true $\forall m \in$ r.matches}{
        \textbf{return} $r.target$
      }
    }
    \textbf{return} $C.policy$
  }
  \caption[Traversing a chain.]{Traversing a chain. A chain aggregates a list
  of \emph{rules} and a \emph{default target} (i.e. policy). A rule contains a
  list of \emph{matches} and a \emph{target}.}
  \label{algo:chain-traversal}
\end{algorithm}

It is possible to express this algorithm in SEFL.  However, there are two
problems with it:
\begin{itemize}
  \item It \textbf{ignores} a couple of essential features in iptables (e.g.
    jumping to user-defined chains).  Thus,
    \labelindexref{Figure}{fig:iptables-2}, even though correct in terms of the
    abstractions it makes, hides a couple of rather involved functionality.
  \item It could be inefficient due to many \hltexttt{if/then/else} statements
    that result.  It is worth reiterating here that SEFL and SymNet do not give
    outstanding performance results by default; they require well crafted
    models.
\end{itemize}

We tackle the former in the next couple of sections.


\subsection{User-defined chains}
\newcommand{\RETURN}{\textbf{\texttt{RETURN}}\xspace}

User-defined chains (also known as user-specified chains, or simply user chains)
differ from built-in chains in that they are not automatically traversed at
specific points in the processing stack of a packet.  Instead, they are
traversed for certain traffic that matches rules they are a target of.  In
other words, built-in chains are unconditionally matched against, while
user-specified chains are conditionally consulted at adjustable points.

One might observe that \labelindexref{Algorithm}{algo:chain-traversal} is still
valid even in the context of rules that jump to user-defined chains, as we can
simply forward packets to another port that applies the same logic using the
rules in that chain.  What actually makes our model a lot more complex is the
special \RETURN target which is essential in advanced iptables configurations
that make great use of user chains.

When a matching rule jumps to \RETURN, the next rule that is matched against is
the successor of the rule that previously caused a jump to the current user
chain, as shown in \labelindexref{Figure}{fig:iptables-user-chains}.
Therefore, when combined with \RETURN, user-specified chains enable chain
traversal orders that resemble function calls in common procedural languages;
the \emph{callee} corresponds to the user chain, the call itself is a jump
action, and the caller is analogous to the original chain where the jump to the
the user chain has been made.

\begin{figure}[h]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[scale=0.6]{src/img/iptables-user-chains}
  \caption[Control flow of user-defined chains in iptables.]{Control flow of
  user-defined chains in iptables, featuring the \RETURN target.  Following the
  function analogy, \texttt{CHAIN1} here can be interpreted as a function that
  encapsulates the logic for filtering out traffic arrived on input interfaces
  other than \emph{eth0}.}
  \label{fig:iptables-user-chains}
\end{figure}

In order to include this behaviour in our chain SEFL models (i.e. chain IVDs),
let us first notice that as long as there is no rule in a chain that might jump
to a user-specified one, \labelindexref{Algorithm}{algo:chain-traversal} is
correct.  Thus, driven by the motivation to reduce our more complicated problem
to one that we know how to solve, we observe that we could obtain \RETURN-free
lists of rules by splitting our original one on boundaries given by rules that
might jump to user-defined chains (called hereafter \textbf{boundary rules}).

An (abstract) example of this idea is presented in
\labelindexref{Figure}{splitting-rules}.  Rectangles correspond to rules in a
chain.  The ones that might jump to user chains are highlighted in red.
Following the boundary rule-splitting idea, three new ordered sublists of rules
result, as pointed out by the dashed brackets.

\begin{figure}[h]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[scale=0.6]{src/img/splitting-rules}
  \caption[Splitting rules in a chain on boundary rules.]{Splitting rules in a
  chain on boundary rules.  A boundary rule is a rule that might jump to a
  user-defined chain.}
  \label{fig:splitting-rules}
\end{figure}

How do we model this new internal structure of a chain IVD using SEFL?
Firstly, by decomposing its previously unified logic into multiple smaller IVDs
called \textbf{contiguous IVDs}. Each one of these new virtual devices that
make up a chain IVD implements the simple traversal algorithm presented in the
previous section for a sublist of rules.  Furthermore, to do this, it turns out
that we do not need to separate boundary rules from the sublist that
\textbf{precede} them.  This is indicated via bold brackets
\labelindexref{Figure}{fig:splitting-rules}.  This separation is not needed
because our splitting guarantees that the last rule in the previous sublist
does not jump to a user chain, and, thus, can lead to two actions only:
\begin{enumerate*}[a)]
  \item matching the rule and jumping to a built-in target (e.g. \texttt{NAT,
    ACCEPT, RETURN, MARK}), and
  \item not matching the rule and \emph{continuing} to the next one,
\end{enumerate*}
none of which could lead to a \RETURN to the succeeding one.  In other words,
we split only \textbf{after} boundary rules because that is the point we might
\textbf{need to return} to.

Besides organizing rules on contiguous IVDs, we also need to link them
together, such that if no rule matches, packets are forwarded to the next one.
Finally, we need to dispatch as part of our SEFL model both input and returned
packets, as follows:
\begin{itemize}
  \item \textbf{Input} packets to one of the (possibly) many contiguous IVDs
    that make up a chain IVD.  That is, newly arrived packets should always be
    forwarded to the first one, while \emph{returning} packets should be
    forwarded to the one that follows the \emph{caller} IVD (using the function
    analogy from a previous paragraph).  To do this, a metadata field is
    allocated and assigned when performing jumps, and deallocated when
    returning.  This is essentially a SEFL stack.  The input dispatch is
    performed by a new virtual device component called
    \textbf{InputTagDispatcher}.
  \item \textbf{Returned} packets to the caller IVD. Since this is a dynamic
    decision too (i.e. multiple chains could jump to the same user chain),
    another tag is stored as a flow metadata which determines the
    \textbf{backlink} to forward the packet to.  The virtual device that does
    this is called \textbf{OutputTagDispatcher}.
\end{itemize}

The resulting internal organization of a virtual device that models a chain is
shown in \labelindexref{Figure}{fig:chain-internal}.

\begin{figure}[h]
  \centering
  \captionsetup{justification=centering}
  \includegraphics[scale=0.5]{src/img/chain-internal}
  \caption[Internal organization of a chain IVD.]{Internal organization of a
  chain IVD.  It has one input port, one accept port, one drop port, a number
  of jump ports equal to the number of rules that might jump to user chains,
  and a variable (but still static) number of backlinks, that corresponds to
  the chains that might jump to this one.  Each \textbf{contiguous IVD} has 1
  input and 5 outputs: one for \texttt{ACCEPT} (green), one for \texttt{DROP}
  (skipped due to lack of space), one for forwarding packet to the next
  contiguous IVD (yellow; for the last one it is given by the chain policy),
  one for jumping to a user chain (magenta; only in the last rule of that
  sublist of rules), and, finally, one for returning to the caller chain (blue;
  managed by \textbf{OutputTagDispatcher}).}
  \label{fig:chain-internal}
\end{figure}

\bigskip

To summarize this section, we started with a model suitable for iptables
configurations that do not make use of the \RETURN target (and, thus, make
little use of user-defined chains) and have extended it to support the control
flow it adds.  We showed how we split a chain of rules into multiple sublists
that can then be modelled as separate contiguous IVDs, a new virtual device we
introduced that applies the naive algorithm presented in the previous section
(\labelindexref{Algorithm}{algo:chain-traversal}).  Finally, we illustrated how
all these new features play out together in a comprehensive diagram
(\labelindexref{Section}{fig:chain-internal}).

\subsection{Network Address Translation}
\todo{start with all kinds of NAT supported? SNAT, DNAT, MASQUERADE (mention
that it is essentially SNAT, since we model data plane only), REDIRECT}
\todo{WHY we treat NAT separately? mention the fact that for each flow, NAT
tables are consulted once only, and then the applied rule is automatically
re-applied; this means that custom logic that SKIPS the table has to be added;
show how this changes the model we reached in the previous section; add the
Chain IVD Initializer components.}
\todo{besides that, reply-packets have to be reverse-NAT'ed}

\subsection{Connection tracking}
\todo{show how we introduce a new \emph{virtual device} that implements the
connection tracking logic. mention that it is currently limited, only NEW to
ESTABLISHED is handled; explain how it works, more precisely; also mention that
a great limitation is discussed in
\labelindexref{Section}{sub-sec:related-state}.}

\bigskip
\todo{conclude by saying that it finalizes the current state of our model,
which is quite involved compared to the initial one we devised at the beginning
of this section.}


\section{Implementation}\label{sec:implementation}
\todo{Could also mention the size of the project; 4k + 4k, "out of tree"
(SymNet); not really "test-driven", but more like "tested"}
\todo{this chapter shows how some of the things discussed in the previous
section are implemented;}
\todo{add implementation-detailed diagrams of the 'iptelement' hierarchy as
well as of the 'virtualdevice' hierarchy; mention composite approach, etc.}
\todo{(inspired by todo 1 above) Discuss what the interface with SymNet is. --
these parts (Instruction/:==:, etc) will be added to a separate "api" package,
to be easily accessed by other models and for better code organization.}
\todo{Before delving into the next subsections, could also mention code
structure, 3 main directories (core, extensions - one directory for each
extension -, virtdev), the driver in the root}

\subsection{Parsing}
\todo{talk about parsing, table parsing, chain parsing, ParsingContext, rule
parsing, match/target parsing, their extensions, how they are extended, etc}
\todo{for rule parsing, mention the functionality behind the 'match extension
activation', flag -m or --match}
\todo{Monadic, Parsec, functional, haskell etc}

\subsection{Validation}
\todo{WHY it is needed; say that it is analogous to semantic analysis in
compilers}
\todo{use cases: unordered chains (needed), port range validity, certain chains
in certain tables, certain rules in certain tables/chains, etc}
\todo{how it works, validate() function, validateIf variant, ValidationContext}

\subsection{Code generation}
\todo{SeflGenOptions trait, the variant for match extensions and the one for
target extensions}


\section{Extensions}
\todo{is this section still needed? maybe add some examples in the previous
sections, rather than adding another one}
\subsection{TCP and UDP}
\subsection{MARK and CONNMARK}


\section{Limitations}
\todo{We build precise models, as far as our toolset (SymNet, SEFL) permits.
However, there are certain limitations which are discussed next.}

\subsection{The local process}
\todo{say that we are not interested in modelling the local process, as a
correct, or at least close to one, model of that would be the kernel itself,
plus application specific logic.}
\todo{however, one trick we do to allow 'simulation' of traffic generated by
some applications is to expose its output port from figure XX. this permits
starting symbolic execution by injecting a symbolic packet on that port and see
what happens, etc.}

\subsection{The RELATED connection state}\label{sub-sec:related-state}
\todo{say again what its purpose should be; give an use-case}
\todo{Inherent limitation caused by the independence between different flows.}
